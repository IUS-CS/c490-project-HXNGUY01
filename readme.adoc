= CSCI C490 Project - Recipe Manager 


== Section 1 – Motivation for Your App

I will be making a recipe app, where user can create and store their own recipe in to a list. User will also be able to use the built-in search function to look up foods online along with its own recipes and the ability to add the products found online to their existing list along with its recipes. The target audiences for this app are people that want to know certain recipes to the foods that they haven't try and users that want a handy list to store their own recipes.

Some of the recipe/food apps that have similar functions can be primarily found on this website:

https://www.digitaltrends.com/mobile/best-recipe-apps/

I haven't tried them all but I've looked at BBC Good Food and its idea of a built in search function is similar to my app. Also Paprika is an excellent that was recommended to me by a certain someone. All the apps listed can be found on both Android and iOS, including the apps listed on the linked website.  

== Section 2 - Meeting Minimum Requirements

=== 2.1 User Interface

There are two main screens on the app. Those screens are the default adding recipe screen and the search recipe screen.

Also I think a list would work better in portrait screen rather than landscape, since there isn't a lot of information being displayed for each product/recipe and for a long list your finger would feel more natural doing a downward swiping motion going through a list in portrait mode rather than in landscape. It's kinda like going through your phone number list, short amount of informations being displayed to me means easier manipulation of a smaller controlled field, in this case a list.

== Add
 

There are two sub-screens on the Add Screen:

• Default screen

  ∙ User can see a list of recipe that they've created
  
  ∙ User have the option to click one of the listed recipe to edit the recipe chosen
  
  ∙ User can click on the add button to assign their own recipe to the list  
  
• Recipe Screen

   ∙ User input into open field the name, ingredients and instructions of how to make the recipe.
   
   ∙ User can click submit after done to add the recipe to their list.
   
   
There are two sub-screens to the Search Screen:

• Default screen

  ∙ User can enter their choosen recipe and click search, the built in search engine will then proceed to look up online and find the closest match to user's chosen product
  
• Browser Screen

  ∙ After searching for a recipe, user will be present with a list of found products online along with its recipe
  
  ∙ User can either click on the name or picture of the product, their information will be saved onto a list. 
  
  ∙ CLicking Add Recipe on the top right corner of the screen after chosing their products will add that product along with its recipe to the main screen.
  
== Handrawn layouts
image::20191009_200838.jpg[float='left']
  
=== 2.2 Data Persistence

Data in this app will be stored in a SQLite database. There aren't much data to be store so data will be stored on the device. Data will be added when user choose to add a recipe of their own into their respective fields, data will be retrieved at the onCreate for the createtable function, there will also be an onUpgrade that will drop the old table and add a new table once triggered. 


=== 2.3 Communication
This app will communicate with the outside world via its search function. The app will be using a simple RESTAPI called recipepuppy, this api lets you search through recipe puppy database of over a million recipes by keyword and/or by search query. The api is accessible at http://www.recipepuppy.com/api/. I found this API by googling recipe api, I haven't decided on a Rest Client yet to retrive and return the json but I've looked online and found that people mostly recommend RetroFit so I'll look into that.

== Section 3 – MVC Breakdown of Your App

In this section, you must utilize the MVC Design Pattern to describe each of the screens supported by your app.
There are a couple of ways you might go about organizing this section of your document:

1. This approach uses one design document section per screen – i.e., provide View, Model, and Controller descriptions about each screen, one screen’s MVC set of descriptions after another
2. This approach has three sections, a View section, a Model section, and a Controller section. In the View section provide a description of each screen appearing in your app, in the Model section provide a description of all Java classes used in the model, in the Controller section provide a description of all controllers required by your app

=== 3.1 View Descriptions

In the description of each screen’s view, provide a diagram (See Section 2.1, above for details about this diagram). These diagrams will more than likely be identical to the ones used to satisfy Section 2 requirements, that is permissible. If the screen contains active widgets, e.g., a Button, then for each of these active widgets you must describe how the user interacts with the widget, what happens when the user does interact with the widget, and the name of the method/operation that is the “listener” for the widget – e.g., user pushes OK button to go back to previous screen, the goBack method in the Java class DataEntryActivity is the listener for this Button.

Include in this part the name of the .xml Layout file associated with each View and the various minimum screen sizes supported (in dp), e.g., 600dp and 800dp. Please include the root layout utilized by each View, e.g., ConstraintLayout, GridLayout, LinearLayout, etc., and why you elected to choose that particular root layout. It might be possible that you have decided to construct a View by writing Java methods and that the View’s .xml file is minimal. If that is the case be sure to name the controller that will be constructing your View along with the names of the methods that will have the implementation code.

=== 3.2 Model Descriptions

Start off with a high-level description of what data needs to be stored, and what Java classes and/or databases/external resources will be utilized to store this data.

For each Java class used to store data, you must supply the name of the class, and a list of all public methods called by clients of the class (note: Controller classes are the likely clients). If a method has a precondition that must be satisfied by the calling client, e.g., a setter method that stores positive integer, then you must include a requires clause stating what the precondition is – this requires clause can be written in English or user mathematics if possible. Utilize design by contract in your design of the model java classes, i.e., if a setter method stores only positive integers, the setter method has a requires clause indicating that the value being supplied by the client must be positive, and the setter method does not have an if statement to check the requires clause.

If your app’s model is utilizing an SQL database or some resource in the cloud, then you must provide a detailed description of this database/resource. For example, for a database answer at least the following, what tables will be present, what columns are in each of the tables, what are the data types of each of the columns, which column (if any) is the key field, how the tables relate to one another, etc.

=== 3.3 Controller Descriptions

Start off with a high-level description of each controller and what screen it controls. Then include which Life Cycle methods are overridden by the controller. This part of the description will almost certainly have to include as a minimum how onCreate is implemented. Describe how and when the controller saves off data into the model, and how and when it retrieves data from the model.

You must describe how your app will satisfy the data persistence requirement in the controller descriptions and/or the model descriptions. If the model is designed so that it always keeps the persistent data store up-to-date, then the model description will more than likely discuss persistence. If the controller is implemented to update the persistent data store at some specific time of the app’s life cycle, then the controller’s description will more than likely discuss persistence. The discussion might need to appear in both the model and the controller descriptions.
