= CSCI C490 Project - Recipe Manager 


== Section 1 – Motivation for Your App

I will be making a recipe app, where user can create and store their own recipe in to a list. User will also be able to use the built-in search function to look up foods online along with its own recipes and the ability to add the products found online to their existing list along with its recipes. The target audiences for this app are people that want to know certain recipes to the foods that they haven't try and users that want a handy list to store their own recipes.

Some of the recipe/food apps that have similar functions can be primarily found on this website:

https://www.digitaltrends.com/mobile/best-recipe-apps/

I haven't tried them all but I've looked at BBC Good Food and its idea of a built in search function is similar to my app. Also Paprika is an excellent that was recommended to me by a certain someone. All the apps listed can be found on both Android and iOS, including the apps listed on the linked website.  

== Section 2 - Meeting Minimum Requirements

In this section, describe using sentences and paragraphs written in English, the screens included in your app’s user interface. Include in this text portion the required diagrams (see below, 2.1 User Interface, Item #5). Describe how your app will not lose any user’s input data when switching between configurations and also among the various screens supported by your app. Items #2 and #4 (below) indicate that exceptions can be made, if you are electing to exercise one or both of these exception, then here is where you must make a compelling argument for the exception.

Additionally, for this section, you must describe how your app will meet the data persistence requirement. Describe where the data will be stored (e.g., on the device, in the cloud, etc.), how it will be stored (e.g., in an SQL database), at what points during app execution that the storage of data will occur (consider using the Android app Life Cycle for describing when), how the data will be retrieved upon restart of the app, and at what point it will be retrieved (again, consider utilizing the Android app Life Cycle).

Finally, for this section, describe how your app will communicate to the outside world. By what means (e.g., Bluetooth, Wi-Fi to Internet, etc.), for what purpose this outside world communication serves with respect to supporting the app’s functionality, and describe what devices or external resources are on the other end of the communication. If the device or other resource at the other end of the communication is going to be created by you (i.e., it does not already exist), then you must give specific details on how you will setup and configure this other device/resource.

=== 2.1 User Interface

There are two main screens on the app. Those screens are the default adding recipe screen and the search recipe screen.

***Note to self: Add diagrams and more info later. 


=== 2.2 Data Persistence

Data in this app will be stored in a SQLite database. There aren't much data to be store so data will be stored on the device. Data will be added when user choose to add a recipe of their own into their respective fields, data will be retrieved at the onCreate for the createtable function, there will also be an onUpgrade that will drop the old table and add a new table once triggered. 


=== 2.3 Communication
This app will communicate with the outside world via its search function. The app will be using a simple RESTAPI called recipepuppy, this api lets you search through recipe puppy database of over a million recipes by keyword and/or by search query. The api is accessible at http://www.recipepuppy.com/api/. I found this API by googling recipe api, I haven't decided on a Rest Client yet to retrive and return the json but I've looked online and found that people mostly recommend RetroFit so I'll look into that.

== Section 3 – MVC Breakdown of Your App

In this section, you must utilize the MVC Design Pattern to describe each of the screens supported by your app.
There are a couple of ways you might go about organizing this section of your document:

1. This approach uses one design document section per screen – i.e., provide View, Model, and Controller descriptions about each screen, one screen’s MVC set of descriptions after another
2. This approach has three sections, a View section, a Model section, and a Controller section. In the View section provide a description of each screen appearing in your app, in the Model section provide a description of all Java classes used in the model, in the Controller section provide a description of all controllers required by your app

=== 3.1 View Descriptions

In the description of each screen’s view, provide a diagram (See Section 2.1, above for details about this diagram). These diagrams will more than likely be identical to the ones used to satisfy Section 2 requirements, that is permissible. If the screen contains active widgets, e.g., a Button, then for each of these active widgets you must describe how the user interacts with the widget, what happens when the user does interact with the widget, and the name of the method/operation that is the “listener” for the widget – e.g., user pushes OK button to go back to previous screen, the goBack method in the Java class DataEntryActivity is the listener for this Button.

Include in this part the name of the .xml Layout file associated with each View and the various minimum screen sizes supported (in dp), e.g., 600dp and 800dp. Please include the root layout utilized by each View, e.g., ConstraintLayout, GridLayout, LinearLayout, etc., and why you elected to choose that particular root layout. It might be possible that you have decided to construct a View by writing Java methods and that the View’s .xml file is minimal. If that is the case be sure to name the controller that will be constructing your View along with the names of the methods that will have the implementation code.

=== 3.2 Model Descriptions

Start off with a high-level description of what data needs to be stored, and what Java classes and/or databases/external resources will be utilized to store this data.

For each Java class used to store data, you must supply the name of the class, and a list of all public methods called by clients of the class (note: Controller classes are the likely clients). If a method has a precondition that must be satisfied by the calling client, e.g., a setter method that stores positive integer, then you must include a requires clause stating what the precondition is – this requires clause can be written in English or user mathematics if possible. Utilize design by contract in your design of the model java classes, i.e., if a setter method stores only positive integers, the setter method has a requires clause indicating that the value being supplied by the client must be positive, and the setter method does not have an if statement to check the requires clause.

If your app’s model is utilizing an SQL database or some resource in the cloud, then you must provide a detailed description of this database/resource. For example, for a database answer at least the following, what tables will be present, what columns are in each of the tables, what are the data types of each of the columns, which column (if any) is the key field, how the tables relate to one another, etc.

=== 3.3 Controller Descriptions

Start off with a high-level description of each controller and what screen it controls. Then include which Life Cycle methods are overridden by the controller. This part of the description will almost certainly have to include as a minimum how onCreate is implemented. Describe how and when the controller saves off data into the model, and how and when it retrieves data from the model.

You must describe how your app will satisfy the data persistence requirement in the controller descriptions and/or the model descriptions. If the model is designed so that it always keeps the persistent data store up-to-date, then the model description will more than likely discuss persistence. If the controller is implemented to update the persistent data store at some specific time of the app’s life cycle, then the controller’s description will more than likely discuss persistence. The discussion might need to appear in both the model and the controller descriptions.
